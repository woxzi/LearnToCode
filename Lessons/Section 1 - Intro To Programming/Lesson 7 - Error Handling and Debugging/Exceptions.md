---
aliases:
  - try
  - catch
  - throw
  - finally
  - try / catch
  - try catch
  - try / catch statements
---
Many different things can cause [[Common Errors|runtime errors]] during the execution of your code. Whenever something goes wrong, an *exception* is thrown that contains information about what went wrong. All exceptions in C# can be considered runtime errors, since they are only thrown when the code is executed.

## Exceptions

#### Throwing Exceptions

When writing code, you can throw exceptions whenever you encounter a situation that you think shouldn't be handled by the scope of your current logic. To do this, you use the `throw` keyword like so:

```cs
Console.WriteLine("Please Enter Potato");
var input = Console.ReadLine();
if (input.ToLower() != "potato") {
	throw new Exception("The input was not potato! I don't know what to do!");
}
```

There are many types of exceptions that can be thrown, but all exceptions [[Future Lesson - Inheritance|inherit]] from the `System.Exception` class in the C# library. You can make your own custom exceptions by writing a new class like so:

```cs
public class CustomException : Exception {
    // empty constructor for when you don't want to write a message
    public CustomException() : base() { }
	
    // constructor to have a message
    public CustomException(string Message) : base(Message) { }
}
```

Doing this creates a new type of exception that can be handled separately using the `try` blocks explained below.

#### Exception Properties

Exceptions are objects that are used to describe the error that occurred within the code, and have a few means of doing so. Below is a list of the different ways an exception might communicate information to you:

- ***Exception Types*** describe what kind of error was thrown, and usually have some name that's loosely related to what went wrong in your code.

- ***Descriptive Messages*** are used to outline the details of what went wrong, and convey information to the person reading the exception in a human-readable format.

- ***Stack Traces*** represent where in the *call stack* the exception was thrown. This allows developers to go in and find the exact line that caused an exception, as well as every method that was called leading up to that point.
#### Call Stacks

Call stacks are objects that represent each method call your code has gone through to get to the point in the code that the call stack is referencing. Whenever an exception is thrown in C#, it will generate a *stack trace*, which is a component of an exception that utilizes a call stack to represent where in the code the exception happened.

Let's use some code to create a more visual example of how this works:

```cs
Foo();

void Foo() {
    Bar();
}

void Baz() {
    throw new Exception();
}

void Bar() {
    Baz();
}
```

When running this code, an exception will be thrown once our execution runs line 8. This exception will generate a stack trace, which can be visualized in the debugger. Here's a screenshot of the call stack window for the exception generated by running the above code:

![[Screenshot 11.png]]

Shown above, we can see that the call stack knows exactly which file the exception occurred in, along with which lines were called in what order. The most recent call will be at the top of the stack. In this case, we called line 1, which called line 4, which called line 12, which finally called line 8 and threw an exception.

When an exception is thrown, it will be thrown to the method that called it unless it's handled in a try/catch statement. That method will then perform the same behavior, causing the exception to "bubble up" to the top of the program unless properly handled in the code.

Because we did not properly handle the thrown exception in the code snippet above, the exception ends up being thrown all the way to the top-level. When exceptions reach the topmost level like this, they immediately halt the program's execution and print out an error that looks something like the below:

```
Unhandled exception. System.Exception: Exception of type 'System.Exception' was thrown.
   at Program.<<Main>$>g__Baz|0_1() in C:\Users\Diego\source\repos\ConsoleApp1\ConsoleApp1\Program.cs:line 8
   at Program.<<Main>$>g__Bar|0_2() in C:\Users\Diego\source\repos\ConsoleApp1\ConsoleApp1\Program.cs:line 12
   at Program.<<Main>$>g__Foo|0_0() in C:\Users\Diego\source\repos\ConsoleApp1\ConsoleApp1\Program.cs:line 4
   at Program.<Main>$(String[] args) in C:\Users\Diego\source\repos\ConsoleApp1\ConsoleApp1\Program.cs:line 1
```

The message printed out whenever this happens will display nearly the same message as a call stack would in your debugger, so you don't need to put breakpoints into your program if you'd like to figure out what went wrong in your code. This can be useful in environments where you execute code outside of visual studio, or when you end up reading log files generated from some library or framework.

## Handling A Thrown Exception

When thrown, exceptions will be thrown to their enclosing scope, and will continue to be thrown upwards until they are caught.  This behavior can only be mitigated by "catching" the exception, using a try/catch statement.

There are three parts of a try/catch statement: `try`, `catch`, and `finally`. You must have at least one `catch` or `finally` clause immediately following a `try` clause for the block to be considered valid code. Let's take a look at a real try/catch statement in code as an example:

```cs
try {
	// your normal everyday logic would go here
} catch (DivideByZeroException e) { // this is how you handle specific error types
	// you can handle the error with any logic in the body here.
	// I chose to print out a message, along with the error's message.
	Console.WriteLine($"We tried to divide by zero here! Error Message: {e.Message}");
} catch { // if you'd like to catch any exception, don't specify a parameter
	// you can also rethrow exceptions if they're caught using an empty throw keyword
	throw;
} finally { // the finally clause is optional. I chose to include it in the block.
	Console.WriteLine("Regardless of if the try was successful, we run this.");
}
```

The `try` section describes code that we're going to run, and expects that an exception might be thrown inside of it. 

When an exception is thrown, it will be caught by a `catch` clause connected to the `try` clause only if the parameter in the `catch` clause matches the type of the thrown exception. If a `catch` does not specify parameters, an exception type of `Exception` is implied, allowing the `catch` clause to accept all exception types. Caught exceptions can be re-thrown by using the `throw` statement inside of the body of the `catch` clause, allowing you to perform some cleanup but still continue throwing the exception. Any number of `catch` clauses can be written connected to a `try` clause

An optional `finally` clause can be written if desired. This clause guarantees that some code is run after a try statement, even if the exception is not handled. This can be useful to perform cleanup operations, like writing to a file or printing specific messages if an error occurs.